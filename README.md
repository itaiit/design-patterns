2019的学习主要参考：[https://blog.csdn.net/LoveLion/article/details/17517213](https://blog.csdn.net/LoveLion/article/details/17517213)，总结自己的理解。

## 7种面向对象设计原则

1. 使用依赖倒置原则设计+里氏转换的理论约束=开闭原则；

   里氏转换原则说明依赖倒置的编程方式是可行的。

2. 接口隔离原则（ISP）=使用单一职责原则的思想+考虑客户端具体的功能需求+适当切分定义接口文件+编程语言支持可实现多接口的语法特性；

   一个接口文件中不宜声明过多的接口，应做适当的切分。

3. 合成复用原则：合理设计对象之间的继承与组合的关系。
4. 迪米特法则：在现在流行的三层软件架构中的体现则是`尽量少的跨层调用相关对象`。

## 单例模式

1. 饿汉式：类加载时即创建一个静态实例保存在内存中；
2. 懒汉式(`synchronized`)；
3. _静态内部类_；

## 工厂模式

### 简单工厂模式

根据传递给静态工厂方法参数的不同，来创建不同的对象。可以是继承自同一个`abstract`类的不同的product，也可以是实现同一个`interface`的不同product。

### 工厂方法模式

针对于简单工厂模式扩展时，违背了‘开闭原则’，工厂方法模式应运而生。

![](20130712101002890.jpg)

工厂方法模式的实现：即工厂`factory`与产品`product`建立相同的层级结构，每一种产品对应于创建自己实例的工厂，这样有新产品加入时，只需在产品层级和工厂层级分别扩充即可，无需修改现有代码逻辑。

适用场景：

- 使用工厂方法时，客户端不知道它所需要的对象的类，只需要知道所对应的工厂即可；
- 抽象工厂类只需要提供一个创建产品的接口，由子类确定具体要创建的对象；

### 抽象工厂方法(<u>产品簇</u>，产品等级结构)

买到不同的汽车零件，在工厂中组装出一辆汽车。

如果把工厂方法模式看作是_纵向单一_的创建，抽象工厂方法则是对于产品簇的_横向组合_的创建：

![](20130713164620203.jpg)

_抽象工厂的局限性_：不能添加新的零件产品线。究其原因是在顶层抽象接口中不存在创建新零件这一接口。

#### 使用该模式的典型的应用场景：

属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是_没有任何关系的对象，但是它们都具有一些共同的约束_，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。

